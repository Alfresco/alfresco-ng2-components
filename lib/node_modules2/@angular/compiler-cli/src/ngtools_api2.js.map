{"version":3,"file":"ngtools_api2.js","sourceRoot":"","sources":["../../../../packages/compiler-cli/src/ngtools_api2.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAkBH,+BAAiC;AAEjC,qDAA6E;AAE7E,8DAAsF;AACtF,kDAA0E;AA4C1E,IAAY,SASX;AATD,WAAY,SAAS;IACnB,uCAAY,CAAA;IACZ,qCAAW,CAAA;IACX,iDAAiB,CAAA;IACjB,qDAAmB,CAAA;IACnB,gDAAgB,CAAA;IAEhB,gDAA4B,CAAA;IAC5B,wCAAgD,CAAA;AAClD,CAAC,EATW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QASpB;AA+CD,6BAA6B;AAC7B,uBACI,EAC6F;QAD5F,wBAAS,EAAE,oBAAO,EAAE,cAAI,EAAE,0BAAU;IAGvC,MAAM,CAAC,uBAAiB,CAAC,EAAC,SAAS,WAAA,EAAE,OAAO,SAAA,EAAE,IAAI,MAAA,EAAE,UAAU,EAAE,UAAiB,EAAC,CAAC,CAAC;AACtF,CAAC;AALD,sCAKC;AAED,kCAAkC;AAClC,4BACI,EACwD;QADvD,oBAAO,EAAE,cAA6C,EAA7C,kEAA6C;IAEzD,MAAM,CAAC,kCAAkB,CAAC,EAAC,OAAO,SAAA,EAAE,MAAM,QAAA,EAAC,CAAC,CAAC;AAC/C,CAAC;AAJD,gDAIC;AAID,2BAAkC,KAAkB;IAClD,MAAM,CAAC,mCAAqB,CAAC,KAAK,CAAC,CAAC;AACtC,CAAC;AAFD,8CAEC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This is a private API for @ngtools/webpack. This API should be stable for NG 5.\n *\n * It contains copies of the interfaces needed and wrapper functions to ensure that\n * they are not broken accidentally.\n *\n * Once the ngc api is public and stable, this can be removed.\n */\n\n/**\n *********************************************************************\n * Changes to this file need to be approved by the Angular CLI team. *\n *********************************************************************\n */\n\nimport {ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {formatDiagnostics as formatDiagnosticsOrig} from './perform_compile';\nimport {Program as ProgramOrig} from './transformers/api';\nimport {createCompilerHost as createCompilerOrig} from './transformers/compiler_host';\nimport {createProgram as createProgramOrig} from './transformers/program';\n\n\n// Interfaces from ./transformers/api;\nexport interface Diagnostic {\n  messageText: string;\n  span?: ParseSourceSpan;\n  category: ts.DiagnosticCategory;\n  code: number;\n  source: 'angular';\n}\n\nexport interface CompilerOptions extends ts.CompilerOptions {\n  basePath?: string;\n  skipMetadataEmit?: boolean;\n  strictMetadataEmit?: boolean;\n  skipTemplateCodegen?: boolean;\n  flatModuleOutFile?: string;\n  flatModuleId?: string;\n  generateCodeForLibraries?: boolean;\n  annotateForClosureCompiler?: boolean;\n  annotationsAs?: 'decorators'|'static fields';\n  trace?: boolean;\n  enableLegacyTemplate?: boolean;\n  disableExpressionLowering?: boolean;\n  i18nOutLocale?: string;\n  i18nOutFormat?: string;\n  i18nOutFile?: string;\n  i18nInFormat?: string;\n  i18nInLocale?: string;\n  i18nInFile?: string;\n  i18nInMissingTranslations?: 'error'|'warning'|'ignore';\n  preserveWhitespaces?: boolean;\n}\n\nexport interface CompilerHost extends ts.CompilerHost {\n  moduleNameToFileName?(moduleName: string, containingFile?: string): string|null;\n  fileNameToModuleName?(importedFilePath: string, containingFilePath: string): string;\n  resourceNameToFileName?(resourceName: string, containingFilePath: string): string|null;\n  toSummaryFileName?(fileName: string, referringSrcFileName: string): string;\n  fromSummaryFileName?(fileName: string, referringLibFileName: string): string;\n  readResource?(fileName: string): Promise<string>|string;\n}\n\nexport enum EmitFlags {\n  DTS = 1 << 0,\n  JS = 1 << 1,\n  Metadata = 1 << 2,\n  I18nBundle = 1 << 3,\n  Codegen = 1 << 4,\n\n  Default = DTS | JS | Codegen,\n  All = DTS | JS | Metadata | I18nBundle | Codegen,\n}\n\nexport interface CustomTransformers {\n  beforeTs?: ts.TransformerFactory<ts.SourceFile>[];\n  afterTs?: ts.TransformerFactory<ts.SourceFile>[];\n}\n\nexport interface TsEmitArguments {\n  program: ts.Program;\n  host: CompilerHost;\n  options: CompilerOptions;\n  targetSourceFile?: ts.SourceFile;\n  writeFile?: ts.WriteFileCallback;\n  cancellationToken?: ts.CancellationToken;\n  emitOnlyDtsFiles?: boolean;\n  customTransformers?: ts.CustomTransformers;\n}\n\nexport interface TsEmitCallback { (args: TsEmitArguments): ts.EmitResult; }\n\nexport interface LazyRoute {\n  module: {name: string, filePath: string};\n  route: string;\n  referencedModule: {name: string, filePath: string};\n}\n\nexport interface Program {\n  getTsProgram(): ts.Program;\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\n  getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\n  getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n  getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<Diagnostic>;\n  loadNgStructureAsync(): Promise<void>;\n  listLazyRoutes(entryRoute?: string): LazyRoute[];\n  emit({emitFlags, cancellationToken, customTransformers, emitCallback}: {\n    emitFlags?: EmitFlags,\n    cancellationToken?: ts.CancellationToken,\n    customTransformers?: CustomTransformers,\n    emitCallback?: TsEmitCallback\n  }): ts.EmitResult;\n}\n\n// Wrapper for createProgram.\nexport function createProgram(\n    {rootNames, options, host, oldProgram}:\n        {rootNames: string[], options: CompilerOptions, host: CompilerHost, oldProgram?: Program}):\n    Program {\n  return createProgramOrig({rootNames, options, host, oldProgram: oldProgram as any});\n}\n\n// Wrapper for createCompilerHost.\nexport function createCompilerHost(\n    {options, tsHost = ts.createCompilerHost(options, true)}:\n        {options: CompilerOptions, tsHost?: ts.CompilerHost}): CompilerHost {\n  return createCompilerOrig({options, tsHost});\n}\n\n// Wrapper for formatDiagnostics.\nexport type Diagnostics = ReadonlyArray<ts.Diagnostic|Diagnostic>;\nexport function formatDiagnostics(diags: Diagnostics): string {\n  return formatDiagnosticsOrig(diags);\n}\n"]}