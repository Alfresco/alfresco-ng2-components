{"version":3,"file":"api.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/api.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAKU,QAAA,kBAAkB,GAAG,GAAG,CAAC;AACzB,QAAA,kBAAkB,GAAG,GAAG,CAAC;AACzB,QAAA,MAAM,GAAG,SAAsB,CAAC;AAkB7C,wBAA+B,UAAe;IAC5C,MAAM,CAAC,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,MAAM,KAAK,SAAS,CAAC;AAC/D,CAAC;AAFD,wCAEC;AAED,wBAA+B,UAAe;IAC5C,MAAM,CAAC,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,MAAM,KAAK,SAAS,CAAC;AAC/D,CAAC;AAFD,wCAEC;AA8KD,IAAY,SASX;AATD,WAAY,SAAS;IACnB,uCAAY,CAAA;IACZ,qCAAW,CAAA;IACX,iDAAiB,CAAA;IACjB,qDAAmB,CAAA;IACnB,gDAAgB,CAAA;IAEhB,gDAA4B,CAAA;IAC5B,wCAAgD,CAAA;AAClD,CAAC,EATW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QASpB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {GeneratedFile, ParseSourceSpan, Position} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nexport const DEFAULT_ERROR_CODE = 100;\nexport const UNKNOWN_ERROR_CODE = 500;\nexport const SOURCE = 'angular' as 'angular';\n\nexport interface DiagnosticMessageChain {\n  messageText: string;\n  position?: Position;\n  next?: DiagnosticMessageChain;\n}\n\nexport interface Diagnostic {\n  messageText: string;\n  span?: ParseSourceSpan;\n  position?: Position;\n  chain?: DiagnosticMessageChain;\n  category: ts.DiagnosticCategory;\n  code: number;\n  source: 'angular';\n}\n\nexport function isTsDiagnostic(diagnostic: any): diagnostic is ts.Diagnostic {\n  return diagnostic != null && diagnostic.source !== 'angular';\n}\n\nexport function isNgDiagnostic(diagnostic: any): diagnostic is Diagnostic {\n  return diagnostic != null && diagnostic.source === 'angular';\n}\n\nexport interface CompilerOptions extends ts.CompilerOptions {\n  // Write statistics about compilation (e.g. total time, ...)\n  // Note: this is the --diagnostics command line option from TS (which is @internal\n  // on ts.CompilerOptions interface).\n  diagnostics?: boolean;\n\n  // Absolute path to a directory where generated file structure is written.\n  // If unspecified, generated files will be written alongside sources.\n  // @deprecated - no effect\n  genDir?: string;\n\n  // Path to the directory containing the tsconfig.json file.\n  basePath?: string;\n\n  // Don't produce .metadata.json files (they don't work for bundled emit with --out)\n  skipMetadataEmit?: boolean;\n\n  // Produce an error if the metadata written for a class would produce an error if used.\n  strictMetadataEmit?: boolean;\n\n  // Don't produce .ngfactory.js or .ngstyle.js files\n  skipTemplateCodegen?: boolean;\n\n  // Always report errors when the type of a parameter supplied whose injection type cannot\n  // be determined. When this value option is not provided or is `false`, constructor\n  // parameters of classes marked with `@Injectable` whose type cannot be resolved will\n  // produce a warning. With this option `true`, they produce an error. When this option is\n  // not provided is treated as if it were `false`. In Angular 6.0, if this option is not\n  // provided, it will be treated as `true`.\n  strictInjectionParameters?: boolean;\n\n  // Whether to generate a flat module index of the given name and the corresponding\n  // flat module metadata. This option is intended to be used when creating flat\n  // modules similar to how `@angular/core` and `@angular/common` are packaged.\n  // When this option is used the `package.json` for the library should refered to the\n  // generated flat module index instead of the library index file. When using this\n  // option only one .metadata.json file is produced that contains all the metadata\n  // necessary for symbols exported from the library index.\n  // In the generated .ngfactory.ts files flat module index is used to import symbols\n  // includes both the public API from the library index as well as shrowded internal\n  // symbols.\n  // By default the .ts file supplied in the `files` files field is assumed to be\n  // library index. If more than one is specified, uses `libraryIndex` to select the\n  // file to use. If more than on .ts file is supplied and no `libraryIndex` is supplied\n  // an error is produced.\n  // A flat module index .d.ts and .js will be created with the given `flatModuleOutFile`\n  // name in the same location as the library index .d.ts file is emitted.\n  // For example, if a library uses `public_api.ts` file as the library index of the\n  // module the `tsconfig.json` `files` field would be `[\"public_api.ts\"]`. The\n  // `flatModuleOutFile` options could then be set to, for example `\"index.js\"`, which\n  // produces `index.d.ts` and  `index.metadata.json` files. The library's\n  // `package.json`'s `module` field would be `\"index.js\"` and the `typings` field would\n  // be `\"index.d.ts\"`.\n  flatModuleOutFile?: string;\n\n  // Preferred module id to use for importing flat module. References generated by `ngc`\n  // will use this module name when importing symbols from the flat module. This is only\n  // meaningful when `flatModuleOutFile` is also supplied. It is otherwise ignored.\n  flatModuleId?: string;\n\n  // Whether to generate code for library code.\n  // If true, produce .ngfactory.ts and .ngstyle.ts files for .d.ts inputs.\n  // Default is true.\n  generateCodeForLibraries?: boolean;\n\n  // Whether to enable all type checks for templates.\n  // This will be true be default in Angular 6.\n  fullTemplateTypeCheck?: boolean;\n\n  // Insert JSDoc type annotations needed by Closure Compiler\n  annotateForClosureCompiler?: boolean;\n\n  // Modify how angular annotations are emitted to improve tree-shaking.\n  // Default is static fields.\n  // decorators: Leave the Decorators in-place. This makes compilation faster.\n  //             TypeScript will emit calls to the __decorate helper.\n  //             `--emitDecoratorMetadata` can be used for runtime reflection.\n  //             However, the resulting code will not properly tree-shake.\n  // static fields: Replace decorators with a static field in the class.\n  //                Allows advanced tree-shakers like Closure Compiler to remove\n  //                unused classes.\n  annotationsAs?: 'decorators'|'static fields';\n\n  // Print extra information while running the compiler\n  trace?: boolean;\n\n  // Whether to enable support for <template> and the template attribute (false by default)\n  enableLegacyTemplate?: boolean;\n\n  // Whether to enable lowering expressions lambdas and expressions in a reference value\n  // position.\n  disableExpressionLowering?: boolean;\n\n  // Locale of the application\n  i18nOutLocale?: string;\n  // Export format (xlf, xlf2 or xmb)\n  i18nOutFormat?: string;\n  // Path to the extracted message file\n  i18nOutFile?: string;\n\n  // Import format if different from `i18nFormat`\n  i18nInFormat?: string;\n  // Locale of the imported translations\n  i18nInLocale?: string;\n  // Path to the translation file\n  i18nInFile?: string;\n  // How to handle missing messages\n  i18nInMissingTranslations?: 'error'|'warning'|'ignore';\n\n  // Whether to remove blank text nodes from compiled templates. It is `true` by default\n  // in Angular 5 and will be re-visited in Angular 6.\n  preserveWhitespaces?: boolean;\n\n  /** generate all possible generated files  */\n  allowEmptyCodegenFiles?: boolean;\n\n  /**\n   * Whether to generate .ngsummary.ts files that allow to use AOTed artifacts\n   * in JIT mode. This is off by default.\n   */\n  enableSummariesForJit?: boolean;\n\n  /** @internal */\n  collectAllErrors?: boolean;\n}\n\nexport interface CompilerHost extends ts.CompilerHost {\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e. `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName?(moduleName: string, containingFile: string): string|null;\n  /**\n   * Converts a file path to a module name that can be used as an `import ...`\n   * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n   */\n  fileNameToModuleName?(importedFilePath: string, containingFilePath: string): string;\n  /**\n   * Converts a file path for a resource that is used in a source file or another resource\n   * into a filepath.\n   */\n  resourceNameToFileName?(resourceName: string, containingFilePath: string): string|null;\n  /**\n   * Converts a file name into a representation that should be stored in a summary file.\n   * This has to include changing the suffix as well.\n   * E.g.\n   * `some_file.ts` -> `some_file.d.ts`\n   *\n   * @param referringSrcFileName the soure file that refers to fileName\n   */\n  toSummaryFileName?(fileName: string, referringSrcFileName: string): string;\n  /**\n   * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\n   * given the fileName of the library that is referrig to it.\n   */\n  fromSummaryFileName?(fileName: string, referringLibFileName: string): string;\n  /**\n   * Load a referenced resource either statically or asynchronously. If the host returns a\n   * `Promise<string>` it is assumed the user of the corresponding `Program` will call\n   * `loadNgStructureAsync()`. Returing  `Promise<string>` outside `loadNgStructureAsync()` will\n   * cause a diagnostics diagnostic error or an exception to be thrown.\n   */\n  readResource?(fileName: string): Promise<string>|string;\n  /**\n   * Produce an AMD module name for the source file. Used in Bazel.\n   *\n   * An AMD module can have an arbitrary name, so that it is require'd by name\n   * rather than by path. See http://requirejs.org/docs/whyamd.html#namedmodules\n   */\n  amdModuleName?(sf: ts.SourceFile): string|undefined;\n}\n\nexport enum EmitFlags {\n  DTS = 1 << 0,\n  JS = 1 << 1,\n  Metadata = 1 << 2,\n  I18nBundle = 1 << 3,\n  Codegen = 1 << 4,\n\n  Default = DTS | JS | Codegen,\n  All = DTS | JS | Metadata | I18nBundle | Codegen,\n}\n\nexport interface CustomTransformers {\n  beforeTs?: ts.TransformerFactory<ts.SourceFile>[];\n  afterTs?: ts.TransformerFactory<ts.SourceFile>[];\n}\n\nexport interface TsEmitArguments {\n  program: ts.Program;\n  host: CompilerHost;\n  options: CompilerOptions;\n  targetSourceFile?: ts.SourceFile;\n  writeFile?: ts.WriteFileCallback;\n  cancellationToken?: ts.CancellationToken;\n  emitOnlyDtsFiles?: boolean;\n  customTransformers?: ts.CustomTransformers;\n}\n\nexport interface TsEmitCallback { (args: TsEmitArguments): ts.EmitResult; }\n\n/**\n * @internal\n */\nexport interface LibrarySummary {\n  fileName: string;\n  text: string;\n  sourceFile?: ts.SourceFile;\n}\n\nexport interface LazyRoute {\n  route: string;\n  module: {name: string, filePath: string};\n  referencedModule: {name: string, filePath: string};\n}\n\nexport interface Program {\n  /**\n   * Retrieve the TypeScript program used to produce semantic diagnostics and emit the sources.\n   *\n   * Angular structural information is required to produce the program.\n   */\n  getTsProgram(): ts.Program;\n\n  /**\n   * Retrieve options diagnostics for the TypeScript options used to create the program. This is\n   * faster than calling `getTsProgram().getOptionsDiagnostics()` since it does not need to\n   * collect Angular structural information to produce the errors.\n   */\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve options diagnostics for the Angular options used to create the program.\n   */\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\n\n  /**\n   * Retrieve the syntax diagnostics from TypeScript. This is faster than calling\n   * `getTsProgram().getSyntacticDiagnostics()` since it does not need to collect Angular structural\n   * information to produce the errors.\n   */\n  getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve the diagnostics for the structure of an Angular application is correctly formed.\n   * This includes validating Angular annotations and the syntax of referenced and imbedded HTML\n   * and CSS.\n   *\n   * Note it is important to displaying TypeScript semantic diagnostics along with Angular\n   * structural diagnostics as an error in the program strucutre might cause errors detected in\n   * semantic analysis and a semantic error might cause errors in specifying the program structure.\n   *\n   * Angular structural information is required to produce these diagnostics.\n   */\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\n\n  /**\n   * Retrieve the semantic diagnostics from TypeScript. This is equivilent to calling\n   * `getTsProgram().getSemanticDiagnostics()` directly and is included for completeness.\n   */\n  getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<ts.Diagnostic>;\n\n  /**\n   * Retrieve the Angular semantic diagnostics.\n   *\n   * Angular structural information is required to produce these diagnostics.\n   */\n  getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n      ReadonlyArray<Diagnostic>;\n\n  /**\n   * Load Angular structural information asynchronously. If this method is not called then the\n   * Angular structural information, including referenced HTML and CSS files, are loaded\n   * synchronously. If the supplied Angular compiler host returns a promise from `loadResource()`\n   * will produce a diagnostic error message or, `getTsProgram()` or `emit` to throw.\n   */\n  loadNgStructureAsync(): Promise<void>;\n\n  /**\n   * Returns the lazy routes in the program.\n   * @param entryRoute A reference to an NgModule like `someModule#name`. If given,\n   *              will recursively analyze routes starting from this symbol only.\n   *              Otherwise will list all routes for all NgModules in the program/\n   */\n  listLazyRoutes(entryRoute?: string): LazyRoute[];\n\n  /**\n   * Emit the files requested by emitFlags implied by the program.\n   *\n   * Angular structural information is required to emit files.\n   */\n  emit({emitFlags, cancellationToken, customTransformers, emitCallback}?: {\n    emitFlags?: EmitFlags,\n    cancellationToken?: ts.CancellationToken,\n    customTransformers?: CustomTransformers,\n    emitCallback?: TsEmitCallback\n  }): ts.EmitResult;\n\n  /**\n   * Returns the .d.ts / .ngsummary.json / .ngfactory.d.ts files of libraries that have been emitted\n   * in this program or previous programs with paths that emulate the fact that these libraries\n   * have been compiled before with no outDir.\n   *\n   * @internal\n   */\n  getLibrarySummaries(): Map<string, LibrarySummary>;\n\n  /**\n   * @internal\n   */\n  getEmittedGeneratedFiles(): Map<string, GeneratedFile>;\n\n  /**\n   * @internal\n   */\n  getEmittedSourceFiles(): Map<string, ts.SourceFile>;\n}\n"]}